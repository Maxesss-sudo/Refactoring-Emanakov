Этот код — классический пример «спагетти-кода» с нарушением всех принципов чистого проектирования. Здесь есть дублирование, плохие имена и нарушение логики (вложенные `if` вместо цикла).

Ниже представлена пошаговая инструкция по превращению этого кода в профессиональный проект.

---

## План рефакторинга игры «21»

### Шаг 1: Работа с именами (Naming)

Первым делом нужно сделать код читаемым, чтобы не гадать, что такое `a0`, `a1` и `a2`.

* **Действие:** Переименуй переменные так, чтобы их смысл был понятен без комментариев.
* `a0`  `isCardAvailable` (доступность карты).
* `a1`  `cardValues` (номиналы).
* `a2`  `cardNames` (названия).
* `sum`  `totalScore`.



### Шаг 2: Создание модели данных (Data Classes)

Вместо трех разрозненных массивов, которые связаны только индексами, создай объект.

* **Действие:** Создай класс `Card`.
```java
public class Card {
    //* имя корты
    private final String name;
    //* очки карты
    private final int value;

    //* конструктор класса
    public Card(String name, int value) {
        this.name = name;
        this.value = value;
    }

    //* геттер для получения значения value, исключающий изменение свойства снаружи
    public int getValue() {
        return value;
    }

    //* способ получить доступ к свойству name
    @Override
    public String toString() {
        return name; // Теперь карту можно просто напечатать
    }
}

```

* **Результат:** Вместо трех массивов у тебя будет один список (или массив) объектов: `List<Card> deck`.

### Шаг 3: Устранение дублирования (DRY)

В коде логика «вытянуть карту» повторяется 6 раз. Если ты захочешь изменить логику выпадения карты, тебе придется править её в 6 местах.

* **Действие:** Вынеси процесс получения карты в отдельный метод.
```java
// Логика поиска случайной карты, которой еще нет у игрока
public Card drawCard() {
    if (cards.isEmpty()) return null;
    return cards.remove(0); // Берем верхнюю карту и удаляем её из колоды
}

```


### Шаг 4: Замена вложенных IF на цикл (Control Flow)

Твой код ограничен 6 картами из-за структуры `if-else`. В программировании для повторяющихся действий используются циклы.

* **Действие:** Используй цикл `while` или `do-while`.
* Игра продолжается, пока пользователь отвечает "y" **И** сумма баллов меньше 21.


* **Удаление лишнего:** Тебе нужен только один экземпляр `Scanner` и один `Random`, а не по одному на каждую карту.

### Шаг 5: Инкапсуляция и классы (ООП)

Метод `main` сейчас делает всё: и инициализирует колоду, и общается с пользователем, и считает логику.

* **Действие:** Раздели ответственность.
1. Создай класс `Deck` (Колода), который будет отвечать за хранение карт и выдачу случайной карты.
2. Создай класс `Game`, который будет управлять игровым процессом (циклом).
3. Класс `Main` должен только запускать игру.


### Шаг 6: Культура кода (Code Style)

* **Удали токсичные комментарии.** Фразы вроде "а то ты ЛОХ" недопустимы в профессиональной среде. Комментарии должны объяснять *почему* сделано так, а не *что* делает очевидная строка кода.
* **Используй импорты.** Вместо `java.util.Scanner` напиши `import java.util.Scanner;` в начале файла. Это сделает код чище.
* **Исправь магические числа.** Вместо цифры `37` в `nextInt` (которая к тому же содержит ошибку, так как карт 36) используй `deck.size()`.

---

## Что должно получиться в итоге (Чек-лист)

1. **Нет дублирования кода**: Метод вытягивания карты написан один раз.
2. **Гибкость**: Игра не заканчивается на 6-й карте, можно тянуть, пока не будет перебора.
3. **Читаемость**: Любой человек может понять логику, просто прочитав названия методов (`deck.draw()`, `game.isOver()`).
4. **Безопасность**: Исправлена ошибка выхода за границы массива (в оригинале `nextInt(0, 37)` мог выдать 36, а индекс массива только до 35).

**Хочешь, чтобы я показал пример того, как будет выглядеть метод `drawCard` после рефакторинга?**