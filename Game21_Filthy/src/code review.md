Для студента очень важно увидеть разницу между «кодом, который просто работает» и «кодом, который легко поддерживать». 
Эта методичка подсветит критические ошибки в их исходном коде и объяснит, почему так делать не стоит.

---

## Методичка: Разбор антипаттернов в игре «21»

### 1. Дублирование логики (Copy-Paste programming)

**Ошибка:** Блок вытягивания карты (цикл `while` с `Random`) скопирован 6 раз.

* **В чем вред:** Если вы решите изменить правила (например, добавить вторую колоду), вам придется менять код в 6 местах. Шанс забыть одно место или сделать опечатку — 100%.
* **Как правильно:** Вынести повторяющийся код в метод `drawCard()`.

### 2. «Лестница смерти» (Deeply Nested Ifs)

**Ошибка:** Каждая следующая карта запрашивается внутри блока `if` предыдущей.

* **В чем вред:** Код уходит далеко вправо. Читать такую «пирамиду» невозможно. К тому же, игра жестко ограничена 6 картами. Если игрок вытянет пять «двоек» и «тройку» (всего 13 очков), программа просто закончится, хотя он мог бы тянуть еще.
* **Как правильно:** Использовать цикл `while`, который работает до тех пор, пока условие истинно.

### 3. Магические индексы и разрозненные массивы

**Ошибка:** Использование трех разных массивов (`a0`, `a1`, `a2`), связанных только общим индексом.

* **В чем вред:** Если вы случайно удалите строку в `a2`, но забудете про `a1`, у вас «Король» внезапно станет стоить 10 очков вместо 4. Связь между именем карты и её весом ничем не защищена.
* **Как правильно:** Объединить свойства в один класс `Card`.

### 4. Неправильное использование Random

**Ошибка:** Создание нового объекта `new Random()` внутри каждого `if`.

* **В чем вред:** Это избыточное потребление памяти. Кроме того, вызов `nextInt(0, 37)` опасен: в Java верхняя граница исключается, но если карт 36, то индексы идут от 0 до 35. Число 37 здесь — «магическое», оно никак не связано с реальным размером массивов.
* **Как правильно:** Создать один `Random` или, что еще лучше, перемешать коллекцию один раз (`Collections.shuffle`).

### 5. Утечки ресурсов (Scanner)

**Ошибка:** Создание нового `Scanner(System.in)` на каждом шаге.

* **В чем вред:** Каждый `Scanner` открывает поток ввода. Если их не закрывать, это может привести к утечкам ресурсов. А закрытие одного из них закроет `System.in` для всей программы.
* **Как правильно:** Один `Scanner` на всё время работы приложения.

---

### Чек-лист для самопроверки рефакторинга:

| Признак | Оценка |
| --- | --- |
| **Переменные** | Имеют имена вроде `totalScore` вместо `sum` или `a1`. |
| **Методы** | Метод `main` содержит менее 10 строк кода. |
| **ООП** | Созданы классы `Card` и `Deck`. |
| **Логика** | Использован цикл `while` для запроса новых карт. |
| **Чистота** | В коде нет токсичных комментариев и нецензурных выражений. |

---

### Полезный совет для преподавателя:

Обратите внимание на то, как реализовали **Туз**. 
В исходном коде он стоит 1 очко, в классическом Blackjack — 11 (или 1). 
Рефакторинг — отличный повод обсудить, как легко менять правила игры, если код написан чисто.
